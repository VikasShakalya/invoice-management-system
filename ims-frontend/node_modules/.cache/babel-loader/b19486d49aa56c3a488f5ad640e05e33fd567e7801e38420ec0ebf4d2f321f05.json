{"ast":null,"code":"import axios from 'axios';\nimport { refreshToken, logoutUser } from './auth';\nconst axiosInstance = axios.create({\n  baseURL: 'http://localhost:8000/api/',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true\n});\n\n// Flag to prevent multiple refresh token requests\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\naxiosInstance.interceptors.request.use(config => {\n  const token = localStorage.getItem('accessToken');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\naxiosInstance.interceptors.response.use(response => response, async error => {\n  var _error$response;\n  const originalRequest = error.config;\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\n        return axiosInstance(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      const {\n        access\n      } = await refreshToken();\n      axios.defaults.headers.common['Authorization'] = `Bearer ${access}`;\n      originalRequest.headers['Authorization'] = `Bearer ${access}`;\n      processQueue(null, access);\n      return axiosInstance(originalRequest);\n    } catch (refreshError) {\n      processQueue(refreshError, null);\n      logoutUser();\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\nexport default axiosInstance;","map":{"version":3,"names":["axios","refreshToken","logoutUser","axiosInstance","create","baseURL","timeout","headers","withCredentials","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","localStorage","getItem","Authorization","Promise","response","_error$response","originalRequest","status","_retry","push","then","catch","err","access","defaults","common","refreshError"],"sources":["C:/Users/hp/Desktop/invoice system/ims-frontend/src/api/axiosInstance.js"],"sourcesContent":["import axios from 'axios';\nimport { refreshToken, logoutUser } from './auth';\n\nconst axiosInstance = axios.create({\n  baseURL: 'http://localhost:8000/api/',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  withCredentials: true,\n});\n\n// Flag to prevent multiple refresh token requests\nlet isRefreshing = false;\nlet failedQueue = [];\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  \n  failedQueue = [];\n};\n\naxiosInstance.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem('accessToken');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\naxiosInstance.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n    \n    if (error.response?.status === 401 && !originalRequest._retry) {\n      if (isRefreshing) {\n        return new Promise((resolve, reject) => {\n          failedQueue.push({ resolve, reject });\n        })\n          .then(token => {\n            originalRequest.headers['Authorization'] = `Bearer ${token}`;\n            return axiosInstance(originalRequest);\n          })\n          .catch(err => Promise.reject(err));\n      }\n\n      originalRequest._retry = true;\n      isRefreshing = true;\n\n      try {\n        const { access } = await refreshToken();\n        \n        axios.defaults.headers.common['Authorization'] = `Bearer ${access}`;\n        originalRequest.headers['Authorization'] = `Bearer ${access}`;\n        \n        processQueue(null, access);\n        \n        return axiosInstance(originalRequest);\n      } catch (refreshError) {\n        processQueue(refreshError, null);\n        logoutUser();\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
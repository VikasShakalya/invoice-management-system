{"ast":null,"code":"import axios from 'axios';\nimport { refreshToken, logoutUser } from './auth';\nconst axiosInstance = axios.create({\n  baseURL: 'http://localhost:8000/api/',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true\n});\n\n// Flag to prevent multiple refresh token requests\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\naxiosInstance.interceptors.request.use(config => {\n  const token = localStorage.getItem('accessToken');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\naxiosInstance.interceptors.response.use(response => response, async error => {\n  var _error$response, _error$response2;\n  const originalRequest = error.config;\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\n        return axiosInstance(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      const {\n        access\n      } = await refreshToken();\n      axios.defaults.headers.common['Authorization'] = `Bearer ${access}`;\n      originalRequest.headers['Authorization'] = `Bearer ${access}`;\n      processQueue(null, access);\n      return axiosInstance(originalRequest);\n    } catch (refreshError) {\n      processQueue(refreshError, null);\n      logoutUser();\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 0 || error.code === 'ERR_NETWORK') {\n    console.error('Network error - backend might not be running');\n    error.message = 'Cannot connect to backend server. Please ensure Django server is running on http://localhost:8000';\n  }\n  return Promise.reject(error);\n});\nexport default axiosInstance;","map":{"version":3,"names":["axios","refreshToken","logoutUser","axiosInstance","create","baseURL","timeout","headers","withCredentials","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","localStorage","getItem","Authorization","Promise","response","_error$response","_error$response2","originalRequest","status","_retry","push","then","catch","err","access","defaults","common","refreshError","code","console","message"],"sources":["C:/Users/hp/Desktop/invoice system/ims-frontend/src/api/axiosInstance.js"],"sourcesContent":["import axios from 'axios';\nimport { refreshToken, logoutUser } from './auth';\n\nconst axiosInstance = axios.create({\n  baseURL: 'http://localhost:8000/api/',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  withCredentials: true,\n});\n\n// Flag to prevent multiple refresh token requests\nlet isRefreshing = false;\nlet failedQueue = [];\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  \n  failedQueue = [];\n};\n\naxiosInstance.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem('accessToken');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\naxiosInstance.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n    \n    if (error.response?.status === 401 && !originalRequest._retry) {\n      if (isRefreshing) {\n        return new Promise((resolve, reject) => {\n          failedQueue.push({ resolve, reject });\n        })\n          .then(token => {\n            originalRequest.headers['Authorization'] = `Bearer ${token}`;\n            return axiosInstance(originalRequest);\n          })\n          .catch(err => Promise.reject(err));\n      }\n\n      originalRequest._retry = true;\n      isRefreshing = true;\n\n      try {\n        const { access } = await refreshToken();\n        \n        axios.defaults.headers.common['Authorization'] = `Bearer ${access}`;\n        originalRequest.headers['Authorization'] = `Bearer ${access}`;\n        \n        processQueue(null, access);\n        \n        return axiosInstance(originalRequest);\n      } catch (refreshError) {\n        processQueue(refreshError, null);\n        logoutUser();\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n    \n    if (error.response?.status === 0 || error.code === 'ERR_NETWORK') {\n      console.error('Network error - backend might not be running');\n      error.message = 'Cannot connect to backend server. Please ensure Django server is running on http://localhost:8000';\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}